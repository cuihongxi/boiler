C51 COMPILER V9.00   MYFLASH                                                               11/24/2020 19:27:23 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MYFLASH
OBJECT MODULE PLACED IN .\Objects\myFlash.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE HARD\myFlash.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\HARD\KEYSCAN;.\HA
                    -RD\TM1640;.\HARD;.\HARD\UART\STC8;.\HARD\delay;.\HARD\printf;.\HARD\MPU430-SPI;.\HARD\interface;.\HARD\TAST) DEBUG OBJEC
                    -TEXTEND PRINT(.\Listings\myFlash.lst) OBJECT(.\Objects\myFlash.obj)

line level    source

   1          #include "myFlash.h"
   2          #include "List4_Malloc.H"
   3          /***
   4           * ÄÚ´æ¿½±´
   5           * ·µ»Øpd¿½±´ÍêµÄÏÂÒ»¸öÖ¸Õë
   6           */
   7          u8*  mymemcpy(void* pdat ,const void* psor,u32 len)
   8          {
   9   1              u32 i = 0;
  10   1              u32 temp = len/sizeof(u32);
  11   1              u8* pd = (u8*)pdat;
  12   1              u8* ps = (u8*)psor;
  13   1              for(i=0;i<temp;i++) ((u32*)pd)[i] = ((u32*)ps)[i];
  14   1              i *= sizeof(u32);
  15   1              for(;i<len;i++) pd[i] = ps[i];
  16   1              return &pd[len];
  17   1      }
  18          
  19          /**
  20          *   ´ÓÄ³¸öµØÖ·¶Á³öÊý¾Ý£¬²¢±£³Öµ½src_addrÎªÊ×µÄµØÖ·ÖÐ
  21          *   des_addrÎªÏà¶ÔµØÖ·£º£¨0~FLASH_MAX_SIZE£©
  22          */ 
  23          errorFlash   Flash_Read(u16 des_addr , u8* src_addr,u16 size)
  24          {
  25   1          u8 erro = ERRO_FLASH_OK;
  26   1              u16 startSector = 0;
  27   1              u16 startoffset = 0;
  28   1              u16 globelBody = 0;
  29   1              u16 endOffset = 0;
  30   1              u8* datbuf;
  31   1      
  32   1          if((des_addr + size) > FLASH_MAX_SIZE) return ERRO_FLASH_OUTRANGE;
  33   1              
  34   1          startSector = FLASH_ADDR_BEGIN + (des_addr/FLASH_SECTOR_SIZE)*FLASH_SECTOR_SIZE;    // ¼ÆËãÆðÊ¼ÉÈÇøµØÖ
             -·
  35   1          startoffset = des_addr&(FLASH_SECTOR_SIZE - 1);                                     // ¼ÆËãÉÈÇøÖÐµÄÆ«Ò
             -ÆÁ¿
  36   1      
  37   1          if((size + startoffset) > FLASH_SECTOR_SIZE)
  38   1              globelBody = (size + startoffset - FLASH_SECTOR_SIZE)/FLASH_SECTOR_SIZE;             // ¼ÆËãÍêÕûµÄÉÈÇ
             -ø¸öÊý
  39   1           endOffset = (size + startoffset)&(FLASH_SECTOR_SIZE - 1);                           // ¼ÆËãÄ©Î²×Ö½ÚÆ«
             -ÒÆ
  40   1      
  41   1          /* ¶ÁÊý¾Ý */
  42   1              datbuf = malloc(FLASH_SECTOR_SIZE);
  43   1              if(datbuf == 0) return ERRO_MALLOC_ZERO;
  44   1           FLASH_READ_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);    // ¶ÁÉÈÇø
  45   1          if((startoffset + size) > FLASH_SECTOR_SIZE)                // ³¬³öÒ»¸öÉÈÇø
  46   1          {
  47   2              MemCopy(src_addr,datbuf + startoffset,FLASH_SECTOR_SIZE - startoffset);
  48   2              src_addr += FLASH_SECTOR_SIZE - startoffset;
  49   2            //  printf("read : globelBody = %d\r\n",globelBody);
C51 COMPILER V9.00   MYFLASH                                                               11/24/2020 19:27:23 PAGE 2   

  50   2              while(globelBody --)
  51   2              {
  52   3                  startSector += FLASH_SECTOR_SIZE;
  53   3                  FLASH_READ_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);    // ¶ÁÉÈÇø
  54   3                  MemCopy((u8*)src_addr,(u8*)datbuf,FLASH_SECTOR_SIZE); 
  55   3                  src_addr += FLASH_SECTOR_SIZE;
  56   3              }
  57   2              startSector += FLASH_SECTOR_SIZE;
  58   2              FLASH_READ_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);    // ¶ÁÉÈÇø
  59   2              MemCopy((u8*)src_addr,(u8*)datbuf,endOffset); 
  60   2          }else
  61   1          {
  62   2              MemCopy(src_addr,datbuf + startoffset,size);
  63   2          }
  64   1          free(datbuf);
  65   1          return erro;
  66   1      }
  67          
  68          /**
  69           *  ´Ósrc_addrµØÖ·¶ÁÊý¾Ý£¬Ð´Èëdes_addr
  70          *   des_addrÎªFLASHÏà¶ÔµØÖ·£º£¨0~FLASH_MAX_SIZE£©
  71          */ 
  72          errorFlash   Flash_Write(u16 des_addr , u8* src_addr,u16 size)
  73          {
  74   1          u8 erro = ERRO_FLASH_OK;
  75   1              u16 startSector = 0;
  76   1              u16 startoffset = 0;
  77   1              u16 globelBody = 0;
  78   1              u16 endOffset = 0;
  79   1              u8* datbuf;
  80   1          if((des_addr + size) > FLASH_MAX_SIZE) return ERRO_FLASH_OUTRANGE;
  81   1           startSector = FLASH_ADDR_BEGIN + (des_addr/FLASH_SECTOR_SIZE)*FLASH_SECTOR_SIZE;           // ¼ÆËãÆðÊ¼ÉÈÇøµ
             -ØÖ·
  82   1           startoffset = des_addr&(FLASH_SECTOR_SIZE - 1);                                            // ¼ÆËãÉÈÇøÖÐµÄÆ
             -«ÒÆÁ¿
  83   1          
  84   1          if((size + startoffset) > FLASH_SECTOR_SIZE)
  85   1              globelBody = (size + startoffset - FLASH_SECTOR_SIZE)/FLASH_SECTOR_SIZE;             // ¼ÆËãÍêÕûµÄÉÈÇ
             -ø¸öÊý
  86   1           endOffset = (size + startoffset)&(FLASH_SECTOR_SIZE - 1);                                  // ¼ÆËãÄ©Î²×Ö½ÚÆ
             -«ÒÆ
  87   1              
  88   1              
  89   1          /* Ð´Êý¾Ý */
  90   1          datbuf = malloc_zero(FLASH_SECTOR_SIZE);
  91   1              if(datbuf == 0) return ERRO_MALLOC_ZERO;
  92   1          FLASH_READ_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);                // ¶ÁÉÈÇø
  93   1          FLASH_ERASE(startSector);                                                                   // ²Á³ýÉÈÇ
             -ø
  94   1      
  95   1          if((startoffset + size) > FLASH_SECTOR_SIZE)                                                // ³¬³öÒ»¸
             -öÉÈÇø
  96   1          {
  97   2              MemCopy((u8*)datbuf + startoffset,(u8*)src_addr ,FLASH_SECTOR_SIZE - startoffset);      // ×°ÔØÊý¾
             -Ý 
  98   2              erro |= FLASH_WRITE_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);           // Ð´ÈëÊý¾Ý
  99   2              src_addr += FLASH_SECTOR_SIZE - startoffset;
 100   2           //   printf("write : globelBody = %d\r\n",globelBody);
 101   2              while(globelBody --)
 102   2              {
 103   3                  startSector += FLASH_SECTOR_SIZE;
 104   3                  FLASH_READ_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);          // ¶ÁÉÈÇø
C51 COMPILER V9.00   MYFLASH                                                               11/24/2020 19:27:23 PAGE 3   

 105   3                  FLASH_ERASE(startSector);                                                            // ²Á³ýÉÈ
             -Çø
 106   3                  MemCopy((u8*)datbuf,(u8*)src_addr,FLASH_SECTOR_SIZE);                                // ×°ÔØÊý
             -¾Ý  
 107   3                  erro |= FLASH_WRITE_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);        // Ð´ÈëÊý¾Ý
 108   3                  src_addr += FLASH_SECTOR_SIZE;
 109   3              }
 110   2              startSector += FLASH_SECTOR_SIZE;
 111   2              FLASH_READ_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);             // ¶ÁÉÈÇø
 112   2              FLASH_ERASE(startSector);                                                               // ²Á³ýÉÈÇ
             -ø
 113   2              MemCopy((u8*)datbuf,(u8*)src_addr,endOffset);                                           // ×°ÔØÊý¾
             -Ý  
 114   2              erro |= FLASH_WRITE_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);           // Ð´ÈëÊý¾Ý
 115   2      
 116   2          }
 117   1          else
 118   1          {                                                               // ²Á³ýÉÈÇø
 119   2              MemCopy((u8*)datbuf + startoffset,(u8*)src_addr ,size);                                  // ×°ÔØÊý
             -¾Ý
 120   2                      FLASH_WRITE_SECTORS(startSector,datbuf,FLASH_SECTOR_SIZE);            // Ð´ÈëÊý¾Ý
 121   2      //              printf("startSector = %d\r\n",startSector);
 122   2      
 123   2          }
 124   1          free(datbuf);
 125   1          return erro;
 126   1      
 127   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1851    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      62
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
